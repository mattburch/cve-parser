package main

import (
	"fmt"
	"github.com/PuerkitoBio/goquery"
	"github.com/docopt/docopt.go"
	"io/ioutil"
	"log"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"
)

type cvss struct {
	CVE    string
	Score  float64
	Rating string
	Detail string
	URL    string
	ERR    bool
}

func plainPrint(cvsslist []cvss) {
	for _, cve := range cvsslist {
		fmt.Printf("%v,%v,%v,%v,%v\n", cve.CVE, cve.Score, cve.Rating, cve.Detail, cve.URL)
	}
}

func htmlPrint(cvsslist []cvss) {
	relist := regexp.MustCompile("{{CVELIST}}")
	redetails := regexp.MustCompile("{{CVEDETAILS}}")
	var list, details string
	for _, cve := range cvsslist {
		tab := "\t\t\t\t"
		list += fmt.Sprintf("%v<div><a href=\"http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-%v\">%v</a></div>\n", tab, cve.CVE, cve.CVE)
	}
	for _, cve := range cvsslist {
		tab := "\t\t\t\t\t"
		details += fmt.Sprintf("%v<tr>\n", tab)
		details += fmt.Sprintf("%v<td><a href=\"http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-%v\">%v</a></td>\n", tab, cve.CVE, cve.CVE)
		details += fmt.Sprintf("%v<td>%v</td>\n", tab, cve.Score)
		details += fmt.Sprintf("%v<td>%v</td>\n", tab, cve.Rating)
		details += fmt.Sprintf("%v<td>%v</td>\n", tab, cve.Detail)
		details += fmt.Sprintf("%v</tr>\n", tab)
	}
	t := relist.ReplaceAllString(template, list)
	fmt.Printf("%v", redetails.ReplaceAllString(t, details))
}

func cveDetails(cve string, result string, details []string) (cvss, error) {
	var cvs cvss
	re := regexp.MustCompile(`CVSS v2 Base Score: (.*?) \((.*?)\)`)
	r := re.FindStringSubmatch(result)
	if r == nil {
		return cvs, fmt.Errorf("CVE: '%v' received an error response from NIST", cve)
	}

	score, err := strconv.ParseFloat(r[1], 64)
	if err != nil {
		return cvs, err
	}

	cvs = cvss{
		CVE:    cve,
		Score:  score,
		Rating: r[2],
		Detail: details[0],
		URL:    "http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-" + cve,
		ERR:    false,
	}

	return cvs, nil
}

func cleanString(s string) string {
	re := regexp.MustCompile(`\s+`)
	newstring := strings.Replace(s, "\n", "", -1)
	newstring = re.ReplaceAllString(newstring, " ")

	return newstring
}

func filterSEV(list []cvss, sev string) []cvss {
	var newList []cvss

	for _, cve := range list {
		if cve.Rating == sev {
			newList = append(newList, cve)
		}
	}

	return newList
}

func filterRating(list []cvss, low float64, high float64) []cvss {
	var newList []cvss

	for _, cve := range list {
		if cve.Score >= low && cve.Score <= high {
			newList = append(newList, cve)
		}
	}

	return newList
}

func getData(cve, d string, debug bool) cvss {

	if debug {
		fmt.Printf("Launching CVE request for: %v\n", cve)
	}

	t, err := strconv.Atoi(d)
	if err != nil {
		log.Fatal(err)
	}

	// Setup HTTP Client
	client := http.Client{
		Timeout: time.Duration(t) * time.Second,
	}
	// Setup HTTP Request
	req, err := http.NewRequest("GET", "http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-"+cve, nil)
	if err != nil {
		log.Fatal(err)
	}
	// Set Request Close Header for HTTP/1.1
	req.Header.Add("Connection", "Close")
	res, err := client.Do(req)
	if err != nil {
		if debug {
			fmt.Printf("HTTP Request Error: %v\n", err)
		}
		return cvss{
			CVE:    cve,
			Score:  0,
			Rating: "",
			Detail: "",
			URL:    "",
			ERR:    true,
		}
	}

	doc, err := goquery.NewDocumentFromResponse(res)
	if err != nil {
		if debug {
			fmt.Printf("Request Error: %v\n", err)
		}
		return cvss{
			CVE:    cve,
			Score:  0,
			Rating: "",
			Detail: "",
			URL:    "",
			ERR:    true,
		}
	}
	vulnDetails := strings.Split(doc.Find(".vuln-detail").Find("p").Text(), "\n")
	cvssdetail := cleanString(doc.Find(".cvss-detail").Text())
	cveinfo, err := cveDetails(cve, cvssdetail, vulnDetails)
	if err != nil {
		log.Println(err)
	}
	return cveinfo
}

func main() {
	var cvsslist []cvss

	arguments, err := docopt.Parse(usage, nil, true, "cve-parser 1.0.2", false)
	if err != nil {
		log.Fatal("Error parsing usage. Error: ", err.Error())
	}

	f := arguments["<file>"].(string)
	var sev string
	var low, high float64

	if arguments["--sev"] != nil {
		sev = strings.ToUpper(arguments["--sev"].(string))
	}
	if arguments["--range"] != nil {
		r := strings.Split(arguments["--range"].(string), ",")

		low, err = strconv.ParseFloat(r[0], 64)
		if err != nil {
			log.Fatal(err.Error())
		}
		high, err = strconv.ParseFloat(r[1], 64)
		if err != nil {
			log.Fatal(err.Error())
		}
	}

	data, err := ioutil.ReadFile(f)
	if err != nil {
		log.Fatal(err.Error())
	}

	var cvelist []string
	for _, cve := range strings.Split(string(data), "\n") {
		if cve == "" {
			continue
		}
		cvelist = append(cvelist, cve)
	}

	if arguments["--debug"].(bool) {
		fmt.Printf("Received %v CVEs\n", len(cvelist))
	}

	thread := make(chan cvss)
	buff := make(chan string, 100)

	for _, cve := range cvelist {
		re := regexp.MustCompile(`\d{4}-\d{4}`)
		if cve == "" {
			continue
		} else if !re.MatchString(cve) {
			log.Fatalf("'%v' is an improper CVE", cve)
		}

		go func(cve string) {
			buff <- cve
			c := getData(cve, arguments["-t"].(string), arguments["--debug"].(bool))
			thread <- c
			<-buff
		}(cve)
	}

	for i, _ := range cvelist {
		if i == len(cvelist) {
			if arguments["--debug"].(bool) {
				fmt.Println("All CVEs returned")
			}
			close(thread)
		} else {
			cveinfo := <-thread
			if arguments["--debug"].(bool) {
				fmt.Printf("Received response for CVE: %v\n", cveinfo.CVE)
			}
			if cveinfo.ERR == true {
				if arguments["--debug"].(bool) {
					fmt.Printf("Received error response for CVE: %v\n", cveinfo.CVE)
				}
				continue
			}
			if cveinfo.CVE == "" {
				if arguments["--debug"].(bool) {
					fmt.Printf("Received empty response for CVE: %v\n", cveinfo.CVE)
				}
				continue
			} else {
				cvsslist = append(cvsslist, cveinfo)
			}
		}
	}

	if sev != "" {
		cvsslist = filterSEV(cvsslist, sev)
	} else if low != 0 || high != 0 {
		cvsslist = filterRating(cvsslist, low, high)
	}

	scoreSort(cvsslist)
	if arguments["--html"].(bool) {
		htmlPrint(cvsslist)
	} else {
		plainPrint(cvsslist)
	}
}
